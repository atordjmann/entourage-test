// Need to use the React-specific entry point to import `createApi`
import { RootState, createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";
import { Movie, UpcomingMoviesDto } from "./movies";


// Define a service using a base URL and expected endpoints
export const moviesApiSlice = createApi({
  baseQuery: fetchBaseQuery({ 
    baseUrl: "https://api.themoviedb.org/3/movie/now_playing",
    prepareHeaders: (headers) => {
        const token = process.env.TMDB_TOKEN ?? ''
    
        // If we have a token set in state, let's assume that we should be passing it.
        headers.set('Authorization', `Bearer eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiI1ODhmYmRmMjZlYjRmYzNkMDFiMWEzOWZkNGYxNmVlZCIsInN1YiI6IjY1Zjc1MjQ3ZWI3OWMyMDE2MzUyZjY4NCIsInNjb3BlcyI6WyJhcGlfcmVhZCJdLCJ2ZXJzaW9uIjoxfQ.x9XiYPAOZKRrXaVygnafUn9jwqRv7O1uXJWpmYfg3wU`)
            
        return headers
      },
  }),
  reducerPath: "moviesApi",
  // Tag types are used for caching and invalidation.
  tagTypes: ["Movies"],
  endpoints: (build) => ({
    getMovies: build.query<UpcomingMoviesDto, number>({
      query: (page) => `?page=${page}`,
      // `providesTags` determines which 'tag' is attached to the
      // cached data returned by the query.
      providesTags: (result, error, id) => [{ type: "Movies", id }],
      serializeQueryArgs: ({ endpointName }) => {
        return endpointName
      },
      // Refetch when the page arg changes
      forceRefetch({ currentArg, previousArg }) {
        return currentArg !== previousArg
      },
    }),
  }),
});

// Hooks are auto-generated by RTK-Query
// Same as `moviesApiSlice.endpoints.getMovies.useQuery`
export const { useGetMoviesQuery } = moviesApiSlice;